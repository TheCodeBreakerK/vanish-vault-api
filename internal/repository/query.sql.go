// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package repository

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const addMemberToRoom = `-- name: AddMemberToRoom :one
INSERT INTO room_members (room_id, user_id, role)
VALUES ($1, $2, $3)
RETURNING room_id, user_id, role, created_at
`

type AddMemberToRoomParams struct {
	RoomID uuid.UUID      `json:"room_id"`
	UserID uuid.UUID      `json:"user_id"`
	Role   MemberRoleType `json:"role"`
}

func (q *Queries) AddMemberToRoom(ctx context.Context, arg AddMemberToRoomParams) (RoomMember, error) {
	row := q.db.QueryRow(ctx, addMemberToRoom, arg.RoomID, arg.UserID, arg.Role)
	var i RoomMember
	err := row.Scan(
		&i.RoomID,
		&i.UserID,
		&i.Role,
		&i.CreatedAt,
	)
	return i, err
}

const burnSecret = `-- name: BurnSecret :exec
UPDATE secret_items
SET is_burned = true, burned_at = CURRENT_TIMESTAMP
WHERE id = $1
`

func (q *Queries) BurnSecret(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, burnSecret, id)
	return err
}

const createRoom = `-- name: CreateRoom :one
INSERT INTO vault_rooms (owner_id, name, access_code, expires_at)
VALUES ($1, $2, $3, $4)
RETURNING id, owner_id, name, access_code, expires_at, is_active, created_at
`

type CreateRoomParams struct {
	OwnerID    uuid.UUID          `json:"owner_id"`
	Name       string             `json:"name"`
	AccessCode pgtype.Text        `json:"access_code"`
	ExpiresAt  pgtype.Timestamptz `json:"expires_at"`
}

func (q *Queries) CreateRoom(ctx context.Context, arg CreateRoomParams) (VaultRoom, error) {
	row := q.db.QueryRow(ctx, createRoom,
		arg.OwnerID,
		arg.Name,
		arg.AccessCode,
		arg.ExpiresAt,
	)
	var i VaultRoom
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.Name,
		&i.AccessCode,
		&i.ExpiresAt,
		&i.IsActive,
		&i.CreatedAt,
	)
	return i, err
}

const createSecret = `-- name: CreateSecret :one
INSERT INTO secret_items (room_id, creator_id, encrypted_content, nonce)
VALUES ($1, $2, $3, $4)
RETURNING id, room_id, creator_id, encrypted_content, nonce, is_burned, created_at, burned_at
`

type CreateSecretParams struct {
	RoomID           uuid.UUID `json:"room_id"`
	CreatorID        uuid.UUID `json:"creator_id"`
	EncryptedContent []byte    `json:"encrypted_content"`
	Nonce            []byte    `json:"nonce"`
}

func (q *Queries) CreateSecret(ctx context.Context, arg CreateSecretParams) (SecretItem, error) {
	row := q.db.QueryRow(ctx, createSecret,
		arg.RoomID,
		arg.CreatorID,
		arg.EncryptedContent,
		arg.Nonce,
	)
	var i SecretItem
	err := row.Scan(
		&i.ID,
		&i.RoomID,
		&i.CreatorID,
		&i.EncryptedContent,
		&i.Nonce,
		&i.IsBurned,
		&i.CreatedAt,
		&i.BurnedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (email, provider, provider_id)
VALUES ($1, $2, $3)
RETURNING id, email, provider, provider_id, created_at
`

type CreateUserParams struct {
	Email      string           `json:"email"`
	Provider   AuthProviderType `json:"provider"`
	ProviderID string           `json:"provider_id"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser, arg.Email, arg.Provider, arg.ProviderID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Provider,
		&i.ProviderID,
		&i.CreatedAt,
	)
	return i, err
}

const deleteRoom = `-- name: DeleteRoom :exec
DELETE FROM vault_rooms
WHERE id = $1 AND owner_id = $2
`

type DeleteRoomParams struct {
	ID      uuid.UUID `json:"id"`
	OwnerID uuid.UUID `json:"owner_id"`
}

func (q *Queries) DeleteRoom(ctx context.Context, arg DeleteRoomParams) error {
	_, err := q.db.Exec(ctx, deleteRoom, arg.ID, arg.OwnerID)
	return err
}

const getMemberRole = `-- name: GetMemberRole :one
SELECT role FROM room_members
WHERE room_id = $1 AND user_id = $2
`

type GetMemberRoleParams struct {
	RoomID uuid.UUID `json:"room_id"`
	UserID uuid.UUID `json:"user_id"`
}

func (q *Queries) GetMemberRole(ctx context.Context, arg GetMemberRoleParams) (MemberRoleType, error) {
	row := q.db.QueryRow(ctx, getMemberRole, arg.RoomID, arg.UserID)
	var role MemberRoleType
	err := row.Scan(&role)
	return role, err
}

const getSecretForView = `-- name: GetSecretForView :one
SELECT id, room_id, creator_id, encrypted_content, nonce, is_burned, created_at, burned_at FROM secret_items
WHERE id = $1 AND room_id = $2 AND is_burned = false 
LIMIT 1
`

type GetSecretForViewParams struct {
	ID     uuid.UUID `json:"id"`
	RoomID uuid.UUID `json:"room_id"`
}

func (q *Queries) GetSecretForView(ctx context.Context, arg GetSecretForViewParams) (SecretItem, error) {
	row := q.db.QueryRow(ctx, getSecretForView, arg.ID, arg.RoomID)
	var i SecretItem
	err := row.Scan(
		&i.ID,
		&i.RoomID,
		&i.CreatorID,
		&i.EncryptedContent,
		&i.Nonce,
		&i.IsBurned,
		&i.CreatedAt,
		&i.BurnedAt,
	)
	return i, err
}

const getUserByProvider = `-- name: GetUserByProvider :one
SELECT id, email, provider, provider_id, created_at FROM users
WHERE provider = $1 AND provider_id = $2 LIMIT 1
`

type GetUserByProviderParams struct {
	Provider   AuthProviderType `json:"provider"`
	ProviderID string           `json:"provider_id"`
}

func (q *Queries) GetUserByProvider(ctx context.Context, arg GetUserByProviderParams) (User, error) {
	row := q.db.QueryRow(ctx, getUserByProvider, arg.Provider, arg.ProviderID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Provider,
		&i.ProviderID,
		&i.CreatedAt,
	)
	return i, err
}

const listMyRooms = `-- name: ListMyRooms :many
SELECT r.id, r.owner_id, r.name, r.access_code, r.expires_at, r.is_active, r.created_at FROM vault_rooms r
JOIN room_members m ON r.id = m.room_id
WHERE m.user_id = $1 AND r.is_active = true
`

func (q *Queries) ListMyRooms(ctx context.Context, userID uuid.UUID) ([]VaultRoom, error) {
	rows, err := q.db.Query(ctx, listMyRooms, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []VaultRoom{}
	for rows.Next() {
		var i VaultRoom
		if err := rows.Scan(
			&i.ID,
			&i.OwnerID,
			&i.Name,
			&i.AccessCode,
			&i.ExpiresAt,
			&i.IsActive,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSecretsByRoom = `-- name: ListSecretsByRoom :many
SELECT id, creator_id, created_at, is_burned 
FROM secret_items
WHERE room_id = $1 AND is_burned = false
`

type ListSecretsByRoomRow struct {
	ID        uuid.UUID          `json:"id"`
	CreatorID uuid.UUID          `json:"creator_id"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	IsBurned  pgtype.Bool        `json:"is_burned"`
}

func (q *Queries) ListSecretsByRoom(ctx context.Context, roomID uuid.UUID) ([]ListSecretsByRoomRow, error) {
	rows, err := q.db.Query(ctx, listSecretsByRoom, roomID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListSecretsByRoomRow{}
	for rows.Next() {
		var i ListSecretsByRoomRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatorID,
			&i.CreatedAt,
			&i.IsBurned,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
